"""Base agent interfaces and abstractions.

This module defines the core Agent and Planner interfaces that all
agent implementations must follow. It provides the foundation for
agents with structured execution patterns.
"""

import abc
import typing as _t

from ..id import new_id
from ..tool.base import Tool
from .types import (
    AgentRunInput,
    AgentRunOutput,
    State,
    Step,
)

__all__ = [
    'Agent',
    'AgentRunInput',
    'AgentRunOutput',
    'Planner',
]


class Agent(abc.ABC):
    """Framework-agnostic agent wrapper.

    Typical interaction flow:

        Client ➜ message/stream
        Message.parts = [{type:"text",text:"Summarize this JSON"}, {type:"data",data:{…}}]

        Server SSE #1 ➜ Message
        role:"assistant", parts:[{type:"text",text:"Working…"}]

        Server SSE #2 ➜ TaskStatusUpdateEvent
        status.state:"working", final:false

        Server SSE #3 ➜ TaskArtifactUpdateEvent (append=false)
        artifact.parts:[{type:"data",data:{draft:…}}]

        Server SSE #4 ➜ TaskArtifactUpdateEvent (append=true lastChunk=true)

        Server SSE #5 ➜ TaskStatusUpdateEvent
        status.state:"completed", final:true  ← server closes stream
    """

    id: str
    name: str
    description: str
    version: str
    tools: list[Tool]

    def __init__(
        self,
        *,
        id: str | None = None,
        name: str,
        description: str,
        version: str = '1.0.0',
        tools: list[Tool] | None = None,
    ) -> None:
        """Initialize an agent.

        Args:
            id: Unique identifier for the agent (autogenerated if not provided)
            name: Name of the agent
            description: Description of the agent
            version: Version string
            tools: List of tools the agent can use
        """
        self.name = name
        self.description = description
        self.version = version
        self.id = id or new_id(prefix=self.name)
        self.tools = tools or []

    @abc.abstractmethod
    async def run(self, input: AgentRunInput) -> AgentRunOutput:
        """Execute agent logic and return structured output."""
        ...


class Planner(abc.ABC):
    """Stateless planner that generates execution steps from state.

    The planner uses the codin prompt system for LLM interactions.
    It should use prompt_run(template_name, variables) to interact with LLMs.
    """

    @abc.abstractmethod
    async def next(self, state: State) -> _t.AsyncGenerator[Step, None]:
        """Generate the next execution steps based on current state.

        The planner should use:
        - prompt_run(template_name, variables) for LLM interactions
        - state.tools for available tools
        - state.history for conversation context
        - state.memory for long-term memory access

        Args:
            state: Current comprehensive execution state (READ-ONLY)

        Yields:
            Step objects representing what the agent should do next

        Note:
            The planner must ONLY read from state - any modifications should
            be yielded as Steps for the Agent to execute and apply to state.
        """
        ...

    @abc.abstractmethod
    async def reset(self, state: State) -> None:
        """Reset the planner to the initial state."""
        ...
