import abc
import typing as _t
from datetime import datetime

from ..id import new_id
from ..tool.base import Tool
from ..model.base import BaseLLM
from ..memory.base import Memory
from ..actor.mailbox import Mailbox
from .types import (
    AgentRunInput, 
    AgentRunOutput, 
    Step, 
    StepType, 
    ThinkStep,
    MessageStep,
    ToolCallStep,
    FinishStep,
    State
)

__all__ = [
    "Agent",
    "Planner",
    "AgentRunInput",
    "AgentRunOutput",
]


class Agent(abc.ABC):
    """Framework-agnostic agent wrapper with A2A compatibility.
    
    Typical interaction flow:
    
        Client ➜ message/stream
        Message.parts = [{type:"text",text:"Summarize this JSON"}, {type:"data",data:{…}}]

        Server SSE #1 ➜ Message
        role:"assistant", parts:[{type:"text",text:"Working…"}]

        Server SSE #2 ➜ TaskStatusUpdateEvent
        status.state:"working", final:false

        Server SSE #3 ➜ TaskArtifactUpdateEvent (append=false)
        artifact.parts:[{type:"data",data:{draft:…}}]

        Server SSE #4 ➜ TaskArtifactUpdateEvent (append=true lastChunk=true)

        Server SSE #5 ➜ TaskStatusUpdateEvent
        status.state:"completed", final:true  ← server closes stream
    """

    id: str
    name: str
    description: str
    version: str
    tools: list[Tool]

    def __init__(
        self, 
        *, 
        id: str | None = None, 
        name: str, 
        description: str, 
        version: str = "1.0.0",
        tools: list[Tool] | None = None,
    ) -> None:
        """Initialize an agent with A2A compatibility.
        
        Args:
            id: Unique identifier for the agent (autogenerated if not provided)
            name: Name of the agent
            description: Description of the agent
            version: Version string
            tools: List of tools the agent can use
        """
        self.name = name
        self.description = description
        self.version = version
        self.id = id or new_id(prefix=self.name)
        self.tools = tools or []

    @abc.abstractmethod
    async def run(self, input: AgentRunInput) -> AgentRunOutput:
        """Execute agent logic and return structured output."""
        ...


class Planner(abc.ABC):
    """Stateless planner that generates execution steps from state.
    
    The planner uses the codin prompt system for LLM interactions.
    It should use prompt_run(template_name, variables) to interact with LLMs.
    """
    
    @abc.abstractmethod
    async def next(self, state: State) -> _t.AsyncGenerator[Step, None]:
        """Generate the next execution steps based on current state.
        
        The planner should use:
        - prompt_run(template_name, variables) for LLM interactions
        - state.tools for available tools
        - state.history for conversation context
        - state.memory for long-term memory access
        
        Args:
            state: Current comprehensive execution state (READ-ONLY)
            
        Yields:
            Step objects representing what the agent should do next
            
        Note:
            The planner must ONLY read from state - any modifications should
            be yielded as Steps for the Agent to execute and apply to state.
        """
        ...
    
    @abc.abstractmethod
    async def reset(self, state: State) -> None:
        """Reset the planner to the initial state."""
        ... 